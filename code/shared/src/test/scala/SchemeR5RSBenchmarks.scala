package scalaam.test.language.scheme

import scalaam.core._
import scalaam.language.scheme.SchemeLattice

object SchemeR5RSBenchmarks {

  val bench: List[(String, Any)] = List(
    ("'()", Nil),
    ("'a", Symbol("a")),
    ("((if #f + *) 3 4)", 12),
    ("(* 3 4)", 12),
    ("(* 4)", 4),
    ("(*)", 1),
    ("(+ 3 4)", 7),
    ("(+ 3)", 3),
    ("(+)", 0),
    ("(- 3 4 5)", -6),
    ("(- 3 4)", -1),
    ("(- 3)", -3),
    ("(/ 1 1.0)", 1.0),
    ("(/ 1 2)", 0.5),
    ("(/ 1.0 1)", 1.0),
    ("(/ 4 2)", 2),
    ("(/ 4 2.0)", 2.0),
    ("(< (- (tan 4) (/ (sin 4) (cos 4))) 0.0001)", true),
    ("(< 1 1)", false),
    ("(< 1 2)", true),
    ("(< 2 1)", false),
    ("(< 2.0 2.1)", true),
    ("(< 2.1 2.0)", false),
    ("(<= 1 1)", true),
    ("(<= 1 2)", true),
    ("(<= 2 1)", false),
    ("(<= 2.0 2.1)", true),
    ("(<= 2.1 2.0)", false),
    ("(= 1 1)", true),
    ("(= 2 1)", false),
    ("(> 1 1)", false),
    ("(> 1 2)", false),
    ("(> 2 1)", true),
    ("(> 2.0 2.1)", false),
    ("(> 2.1 2.0)", true),
    ("(>= 1 1)", true),
    ("(>= 1 2)", false),
    ("(>= 2 1)", true),
    ("(>= 2.0 2.1)", false),
    ("(>= 2.1 2.0)", true),
    ("(abs -7)", 7),
    ("(abs 0)", 0),
    ("(abs 7)", 7),
    ("(acos 1)", 0.0),
    ("(and (= 2 2) (< 2 1))", false),
    ("(and (= 2 2) (> 2 1))", true),
    ("(and)", true),
    ("(asin 0)", 0.0),
    ("(assq 'd '((a 1) (b 2) (c 3)))", false),
    ("(assq (list 'a) '(((a)) ((b)) ((c))))", false),
    ("(atan 0)", 0.0),
    ("(boolean? #f)", true),
    ("(boolean? '())", false),
    ("(boolean? 0)", false),
    ("(ceiling -4.3)", -4.0),
    ("(ceiling 3.5)", 4.0),
    ("(char? #\\a)", true),
    ("(char? '())", false),
    ("(char? 0)", false),
    ("(cos 0)", 1.0),
    ("(eq? '() '())", true),
    ("(eq? 'a 'a)", true),
    ("(eq? (cons 'a '()) (cons 'a '()))", false),
    ("(eq? (list 'a) (list 'a))", false),
    ("(eq? car car)", true),
    ("(equal? #\\a #\\b)", false),
    ("(equal? '(a (b) c) '(a (b) c))", true),
    ("(equal? '(a b c) '(a b))", false),
    ("(equal? '(a b c) '(a c b))", false),
    ("(equal? '(a) '(a))", true),
    ("(equal? 'a 'a)", true),
    ("(equal? (assoc (list 'a) '(((a)) ((b)) ((c)))) '((a)))", true),
    ("(equal? (assq 'a '((a 1) (b 2) (c 3))) '(a 1))", true),
    ("(equal? (assq 'b '((a 1) (b 2) (c 3))) '(b 2))", true),
    ("(equal? (assq 'c '((a 1) (b 2) (c 3))) '(c 3))", true),
    ("(equal? (car '((a) b c d)) '(a))", true),
    ("(equal? (car '(a b c)) 'a)", true),
    ("(equal? (car (cons 1 2)) 1)", true),
    ("(equal? (cdr '((a) b c d)) '(b c d))", true),
    ("(equal? (cdr (cons 1 2)) 2)", true),
    ("(equal? (cons '(a) '(b c d)) '((a) b c d))", true),
    ("(equal? (cons 'a '()) '(a))", true),
    ("(equal? (cons 'a (cons 'b (cons 'c '()))) '(a b c))", true),
    ("(equal? (cons \"a\" '(b c)) '(\"a\" b c))", true),
    ("(equal? (list 'a (+ 3 4) 'c) '(a 7 c))", true),
    ("(equal? (member (list 'a) '(b (a) c)) '((a) c))", true),
    ("(equal? (memq 'a '(a b c)) '(a b c))", true),
    ("(equal? (memq 'b '(a b c)) '(b c))", true),
    ("(equal? 1 2)", false),
    ("(equal? 2 2)", true),
    ("(equal? \"abc\" \"abc\")", true),
    ("(eqv? #f 'nil)", false),
    ("(eqv? '() '())", true),
    ("(eqv? 'a 'a)", true),
    ("(eqv? 'a 'b)", false),
    ("(eqv? (cons 1 2) (cons 1 2))", false),
    ("(eqv? (lambda () 1) (lambda () 2))", false),
    ("(eqv? 100000000 100000000)", true),
    ("(eqv? 2 2)", true),
    ("(even? -1)", false),
    ("(even? -2)", true),
    ("(even? 0)", true),
    ("(even? 1)", false),
    ("(exact->inexact 0)", 0.0),
    ("(exact->inexact 5)", 5.0),
    ("(expt 0 0)", 1),
    ("(expt 1 0)", 1),
    ("(expt 5 2)", 25),
    ("(floor -4.3)", -5.0),
    ("(floor 3.5)", 3.0),
    ("(floor 7)", 7),
    ("(inexact->exact 0.000)", 0),
    ("(inexact->exact 5.0)", 5),
    ("(integer? '())", false),
    ("(integer? 0)", true),
    ("(length '())", 0),
    ("(length '(a (b) (c d e)))", 3),
    ("(length '(a b c))", 3),
    ("(let ((p (lambda (x) x))) (eq? p p))", true),
    ("(let ((p (lambda (x) x)))\n(eq? p p))", true),
    //("(let ((p (lambda (x) x)))\n(eqv? p p))", true),
    ("(let ((vec (vector 'a 'b 'c))) (and (equal? (vector-ref vec 0) 'a) (equal? (vector-ref vec 1) 'b) (equal? (vector-ref vec 2) 'c)))", true),
    ("(let ((vec (vector 0 '(2 2 2 2) \"Anna\"))) (vector-set! vec 1 '(\"Sue\" \"Sue\")) (and (equal? (vector-ref vec 0) 0) (equal? (vector-ref vec 1) '(\"Sue\" \"Sue\")) (equal? (vector-ref vec 2) \"Anna\")))", true),
    //("(let ((x '#())) (eq? x x))", true),
    ("(let ((x '(a))) (eq? x x))", true),
    // ("(let ((x '(a))) (set-cdr! x x) (list? x))", false), // This is fine for abstract runs, but kills the concrete interpreter (list? is not actually properly defined for circular lists)
    //("(let ((x '(a)))\n(eqv? x x))", true),
    ("(let ((x (cons 1 2))) (set-car! x 3) (and (= (car x) 3) (= (cdr x) 2)))", true),
    ("(let ((x (cons 1 2))) (set-cdr! x 3) (and (= (car x) 1) (= (cdr x) 3)))", true),
    ("(let ((x (make-vector 0 1))) (eq? x x))", true),
    ("(list)", Nil),
    ("(list-ref '(a b c d) (inexact->exact (round 1.8)))", Symbol("c")),
    ("(list-ref '(a b c d) 2)", Symbol("c")),
    ("(list-ref '(a b c) 0)", Symbol("a")),
    ("(list? '((a b) c d))", true),
    ("(list? '())", true),
    ("(list? '(a b c))", true),
    ("(list? 'a)", false),
    ("(list? (cons 'a 'b))", false),
    ("(log 1)", 0.0),
    ("(max 1 2 3 4 5 4 3 2 1)", 5),
    ("(max 1)", 1),
    ("(max 3 4)", 4),
//    ("(max 3.9 4)", 4.0), // disabled for lack of proper precision cast in max primitive
    ("(member 'd '(a b c))", false),
    ("(memq 'a '(b c d))", false),
    ("(memq (list 'a) '(b (a) c))", false),
    ("(min 1)", 1),
    ("(min 3 4)", 3),
    ("(min 3 4.9)", 3),
    ("(min 5 4 3 2 1 2 3 4 5)", 1),
    ("(modulo -13 -4)", -1),
    ("(modulo -13 4)", 3),
    ("(modulo 13 -4)", -3),
    ("(modulo 13 4)", 1),
    ("(negative? -1)", true),
    ("(negative? 0)", false),
    ("(negative? 1)", false),
    ("(not #f)", true),
    ("(not #t)", false),
    ("(not '())", false),
    ("(not 'nil)", false),
    ("(not (cons 3 '()))", false),
    ("(not (list))", false),
    ("(not 3)", false),
    ("(null? '())", true),
    ("(null? '(1 2 3))", false),
    ("(null? (list))", true),
    ("(number->string -123.456)", "-123.456"),
    ("(number->string .5)", "0.5"),
    ("(number->string 0)", "0"),
    ("(number? '())", false),
    ("(number? -1)", true),
    ("(number? 0)", true),
    ("(number? 0.5)", true),
    ("(odd? 0)", false),
    ("(odd? 1)", true),
    ("(odd? 101)", true),
    ("(or #f #f #f)", false),
    ("(or (= 2 2) (< 2 1))", true),
    ("(or (= 2 2) (> 2 1))", true),
    ("(pair? '())", false),
    ("(pair? '(a b c))", true),
    ("(pair? (cons 'a 'b))", true),
    ("(positive? -1)", false),
    ("(positive? 0)", false),
    ("(positive? 1)", true),
    ("(quote a)", Symbol("a")),
    ("(quotient -6 2)", -3),
    ("(quotient 3 5)", 0),
    ("(quotient 4 2)", 2),
    ("(real? 1.5)", true),
    ("(real? 3)", true),
    ("(remainder -13 -4)", -1),
    ("(remainder -13 4)", -1),
    ("(remainder 13 -4)", 1),
    ("(remainder 13 4)", 1),
    ("(sin 0)", 0.0),
    ("(sqrt 0)", 0),
    ("(sqrt 16)", 4),
    ("(sqrt 4)", 2),
    ("(sqrt 4.0)", 2.0),
    ("(string->symbol \"flying-fish\")", Symbol("flying-fish")),
    ("(string-append \"foo\" \"bar\")", "foobar"),
    ("(string-length \"foobar\")", 6),
    ("(string<? \"bar\" \"foo\")", true),
    ("(string<? \"f\" \"foo\")", true),
    ("(string<? \"foo\" \"bar\")", false),
    ("(string<? \"foo\" \"foo\")", false),
    ("(string? 'foo)", false),
    ("(string? 1)", false),
    ("(string? \"\")", true),
    ("(string? \"foo\")", true),
    ("(symbol->string 'flying-fish)", "flying-fish"),
    ("(symbol? #f)", false),
    ("(symbol? '())", false),
    ("(symbol? 'foo)", true),
    ("(symbol? 'nil)", true),
    ("(symbol? (car '(a b)))", true),
    ("(symbol? \"bar\")", false),
    ("(tan 0)", 0.0),
    ("(vector-length (vector 0 1 0))", 3),
    ("(vector-length (vector))", 0),
    ("(vector? 'a)", false),
    ("(vector? (vector 'a 'b 'c))", true),
    ("(zero? -1)", false),
    ("(zero? 0)", true),
    ("(zero? 1)", false),
  )

}

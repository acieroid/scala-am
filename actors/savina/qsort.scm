(define T (int-top))
(define (build-vector n f)
  (letrec ((v (make-vector n #f))
           (loop (lambda (i)
                   (if (< i n)
                       (begin
                         (vector-set! v i (f i))
                         (loop (+ i 1)))
                       v))))
    (loop 0)))
(define (append l m)
  (if (null? l)
      m
      (cons (car l) (append (cdr l) m))))
(define (filter f l)
  (if (pair? l)
      (let ((head (car l)))
        (if (f head)
            (cons head (filter f (cdr l)))
            (filter f (cdr l))))
      l))
(define InputSize (int-top))
(define Input (letrec ((loop (lambda (i acc)
                               (if (= i InputSize)
                                   acc
                                   (loop (+ i 1) (cons (int-top) acc))))))
                (loop 0 '())))

(define (qsort-seq data)
  (let* ((data-length (length data))
         (pivot (list-ref data (inexact->exact (round (/ data-length 2)))))
         (left-unsorted (filter (lambda (x) (< x pivot)) data))
         (left-sorted (qsort-seq left-unsorted))
         (equal-elements (filter (lambda (x) (= x pivot)) data))
         (right-unsorted (filter (lambda (x) (> x pivot)) data))
         (right-sorted (qsort-seq right-unsorted))
         (sorted (append left-sorted (append equal-elements right-sorted))))
    sorted))

(define quicksort-actor
  (a/actor "quicksort-actor" (parent position-relative-to-parent result num-fragments)
           (sort (data)
                 (if (< (length data) T)
                     (let ((result (if (= (length data) 1) data (qsort-seq data))))
                       (if parent
                           (a/send parent result result position-relative-to-parent))
                       (a/terminate))
                     (let* ((data-length-half (inexact->exact (round (/ (length data) 2))))
                            (pivot (list-ref data data-length-half))
                            (left-unsorted (filter (lambda (x) (< x pivot)) data))
                            (left-actor (a/create quicksort-actor self 'position-left '() 0))
                            (right-unsorted (filter (lambda (x) (> x pivot)) data))
                            (right-actor (a/create quicksort-actor self 'position-right '() 0)))
                       (a/send left-actor sort left-unsorted)
                       (a/send right-actor sort right-unsorted)
                       (a/become quicksort-actor parent position-relative-to-parent (filter (lambda (x) (= x pivot)) data) (+ num-fragments 1)))))
           (result (data position)
                   (let ((result2
                          (if (empty? data)
                              result
                              (if (equal? position 'position-left)
                                  (append data result)
                                  (if (equal? position 'position-right)
                                      (append result data)
                                      result)))))
                     (if (= (+ num-fragments 1) 3)
                         (begin
                           (if parent
                               (a/send parent result result2 position-relative-to-parent))
                           (a/terminate))
                         (a/become quicksort-actor parent position-relative-to-parent result2 (+ num-fragments 1)))))))
(define root
  (a/create quicksort-actor #f 'position-initial '() 0))
(a/send root sort Input)

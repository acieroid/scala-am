(define (create-redblack-tree . options)
  (define (make-null-tree) 
    (list (cons '() 'black) '() '() '()))
  (let* ((content (make-null-tree))
         (same? (if (null? options) equal?
                    (car options)))
         (less? (if (null? options) < (cadr options))))
    (define (make-node item left right parent)
      (list (cons item 'red) left right parent))
    (define (node-item node)
      (car (car node)))
    (define (node-color node)
      (cdr (car node)))
    (define (node-left node)
      (cadr node))
    (define (node-right node)
      (caddr node))
    (define (node-parent node)
      (cadddr node))
    (define (node-set-item! node item)
      (set-car! (car node) item))
    (define (node-set-color! node color)
      (set-cdr! (car node) color ))
    (define (node-set-color-red! node)
      (set-cdr! (car node) 'red ))
    (define (node-set-color-black! node)
      (set-cdr! (car node) 'black ))
    (define (node-set-left! node son)
      (set-car! (cdr node) son))
    (define (node-set-right! node son)
      (set-car! (cddr node) son))
    (define (node-set-parent! node parent)
      (set-car! (cdddr node) parent))
    (define (null-tree? tree)
      (null? (node-item tree)))
    (define (is-leaf? node)
      (and (null-tree? (node-left node))
           (null-tree? (node-right node))))
    (define (traverse tree order action)
      (define (traverse-preorder tree)
        (cond
          ((null-tree? tree)
           #t)
          (else
           (action (node-item tree) (node-color tree))
           (traverse-preorder (node-left tree))
           (traverse-preorder (node-right tree)))))
      (define (traverse-inorder tree)
        (cond
          ((null-tree? tree)
           #t)
          (else
           (traverse-inorder (node-left tree))
           (action (node-item tree) (node-color tree))
           (traverse-inorder (node-right tree)))))
      (define (traverse-postorder tree)
        (cond
          ((null-tree? tree)
           #t)
          (else
           (traverse-postorder (node-left tree))
           (traverse-postorder (node-right tree))
           (action (node-item tree) (node-color tree)))))
      (case order
        ((preorder)
         (traverse-preorder tree))
        ((inorder)
         (traverse-inorder tree))
        ((postorder)
         (traverse-postorder tree))
        (else
         (error "Unknown tree traversal order"))))
    (define (left-rotate node-x)
      (let ((node-y (node-right node-x)))
        (node-set-right! node-x (node-left node-y))
        (node-set-parent! (node-left node-y) node-x)
        (node-set-parent! node-y (node-parent node-x))
        (if (not (null-tree? (node-parent node-x)))
            (if (same? (node-item node-x) 
                       (node-item (node-left (node-parent node-x))))
                (node-set-left! (node-parent node-x) node-y)
                (node-set-right! (node-parent node-x) node-y))
            (set! content node-y))
        (node-set-left! node-y node-x)
        (node-set-parent! node-x node-y)))
    
    (define (right-rotate node-y)
      (let ((node-x (node-left node-y)))
        (node-set-left! node-y (node-right node-x))
        (node-set-parent! (node-right node-x) node-y)
        (node-set-parent! node-x (node-parent node-y))        
        (if (not (null-tree? (node-parent node-y)))
            (if (same? (node-item node-y) 
                       (node-item (node-left (node-parent node-y))))
                (node-set-left! (node-parent node-y) node-x)
                (node-set-right! (node-parent node-y) node-x))
            (set! content node-x))
        (node-set-right! node-x node-y)
        (node-set-parent! node-y node-x)))
    
    (define (parent-is-in node-x node-branch then-rotate other-rotate)
      (let ((node-y (node-branch (node-parent (node-parent node-x)))))
        (cond ((equal? 'red (node-color node-y))
               (node-set-color-black! (node-parent node-x))
               (node-set-color-black! node-y)
               (node-set-color-red! (node-parent (node-parent node-x)))
               (evaluate-redblack-conditions (node-parent (node-parent node-x))))
              (else
               (if (and (not (null-tree? (node-branch (node-parent node-x))))
                        (same? (node-item node-x)
                               (node-item (node-branch (node-parent node-x)))))
                   (begin 
                     (set! node-x (node-parent node-x))
                     (then-rotate node-x)))
               (node-set-color-black! (node-parent node-x))
               (node-set-color-red! (node-parent (node-parent node-x)))
               (other-rotate (node-parent (node-parent node-x)))
               (evaluate-redblack-conditions node-x)))))
    
    
    (define (evaluate-redblack-conditions node-x)
      (if (and (not (same? (node-item node-x)
                           (node-item content)))
               (equal? 'red (node-color (node-parent node-x)))
               (not (null-tree? (node-parent (node-parent node-x)))))
          (cond ((and
                  (not (null-tree? (node-left (node-parent (node-parent node-x)))))
                  (same? (node-item (node-parent node-x))
                         (node-item (node-left (node-parent (node-parent node-x))))))
                 (parent-is-in node-x node-right left-rotate right-rotate))
                (else
                 (parent-is-in node-x node-left right-rotate left-rotate)))))
        
    (define (child-is-in  node-x main-branch other-branch main-rotate other-rotate)
      (let ((node-w (main-branch (node-parent node-x))))
        (if (equal? 'red (node-color node-w))
            (begin
              (node-set-color-red! (node-parent node-x))
              (node-set-color-black! node-w)
              (main-rotate (node-parent node-x))
              (set! node-w (main-branch (node-parent node-x)))))
        (if (and (eq? 'black  (node-color (node-left node-w)))
                 (eq? 'black  (node-color (node-right node-w))))
            (begin
              (node-set-color-red! node-w)
              (fixup-redblack-conditions (node-parent node-x)))
            (begin
              (if (eq? 'black (node-color (main-branch node-w)))
                  (begin 
                    (node-set-color-black! (other-branch node-w))
                    (node-set-color-red! node-w)
                    (other-rotate node-w)
                    (set! node-w (main-branch (node-parent node-w)))))
              (node-set-color! node-w (node-color (node-parent node-x)))
              (node-set-color-black! (node-parent node-x))
              (node-set-color-black! (main-branch node-w))
              (main-rotate (node-parent node-x))
              (fixup-redblack-conditions content)))))
    
    
    (define (fixup-redblack-conditions node-x)
      (if (and
           (not (same? (node-item node-x)
                       (node-item content)))
           (equal? 'black (node-color node-x)))
          (cond ((same? (node-item node-x)
                        (node-item (node-left (node-parent node-x))))
                 (child-is-in node-x node-right node-left left-rotate right-rotate))
                (else
                 (child-is-in node-x node-left node-right right-rotate left-rotate)))
          (node-set-color-black! node-x)))
    

    (define (empty?)
      (null-tree? content))
    
    (define (lookup element)
      (define (lookup-aux node)
        (cond
          ((null-tree? node)
           #f)
          ((same? element (node-item node))
           (node-item node))
          ((less? element (node-item node))
           (lookup-aux (node-left node)))
          (else
           (lookup-aux (node-right node)))))
      (lookup-aux content))
    
    (define (insert element)
      (define (insert-aux node parent)
        (cond
          ((null-tree? node) 
           (let ((new-node (make-node element (make-null-tree) (make-null-tree) (make-null-tree))))
             (node-set-parent! (node-left new-node) new-node)
             (node-set-parent! (node-right new-node) new-node)             
             (if (not (null-tree? parent))
                 (begin 
                   (node-set-parent! new-node parent)
                   (if (less? element (node-item parent))
                       (node-set-left! parent new-node)                     
                       (node-set-right! parent new-node))
                   (evaluate-redblack-conditions new-node))
                 (begin 
                   (set! content new-node)))
             (node-set-color-black! content)
             #t))
          ((same? element (node-item node))
           (node-set-item! node element)
           #t)
          ((less? element (node-item node))
           (insert-aux (node-left node) node))
          (else
           (insert-aux (node-right node) node))))
      (insert-aux content (make-null-tree)))
    
    (define (delete element)
      (define (left-most-node node parent)
        (if (null-tree? (node-left node))
            node
            (left-most-node (node-left node) node)))
      (define (delete-aux node)
        (cond
          ((null-tree? node)
           #f)
          ((same? element (node-item node))
           (let* ((node-y (if (or (null-tree? (node-left node))
                                  (null-tree? (node-right node)))
                              node
                              (left-most-node (node-right node) #f)))
                  (node-x (if (null-tree? (node-left node-y))
                              (node-right node-y)
                              (node-left node-y))))
             (node-set-parent! node-x (node-parent node-y))
             (if (null-tree? (node-parent node-y))
                 (set! content node-x)
                 (if (and
                      (not (null-tree? (node-left (node-parent node-y))))
                      (same? (node-item node-y)
                             (node-item (node-left (node-parent node-y)))))
                     (node-set-left! (node-parent node-y) node-x)
                     (node-set-right! (node-parent node-y) node-x)))
             (if (not (same? (node-item node-y)
                             (node-item node)))
                 (begin
                   (node-set-item! node (node-item node-y))))
             (if (eq? 'black (node-color node-y))
                 (fixup-redblack-conditions node-x))
             #t))
          ((less? element (node-item node))
           (delete-aux (node-left node)))
          (else
           (delete-aux (node-right node)))))
      (delete-aux content ))
    
    (define (dispatch msg . args)
      (cond
        ((eq? msg 'empty) (empty?))
        ((eq? msg 'insert) (insert (car args)))
        ((eq? msg 'delete) (delete (car args)))
        ((eq? msg 'lookup) (lookup (car args)))
        ((eq? msg 'display) (traverse content  'preorder
                                      (lambda (x c) (display (cons x c)) (newline))))
        (else
         (error "unknown request -- create-BST" msg))))
    dispatch))


(define tree (create-redblack-tree))
(tree 'insert 1)
(tree 'display)
(tree 'insert 2)
(tree 'display)
(tree 'insert 5)
(tree 'display)
(tree 'insert 7)
(tree 'display)
(tree 'insert 8)
(tree 'display)
(tree 'insert 11)
(tree 'display)
(tree 'insert 14)
(tree 'display)
(tree 'insert 15)
(tree 'display)
(tree 'insert 4)
(tree 'display)
(tree 'insert 3)
(tree 'display)
(tree 'delete 1)
(tree 'display)
(tree 'delete 2)
(tree 'display)
(tree 'delete 11)
(tree 'display)
;; BEGIN PRELUDE

(define (equal? a b)
  (or (eq? a b)
    (and (null? a) (null? b))
    (and (pair? a) (pair? b) (equal? (car a) (car b)) (equal? (cdr a) (cdr b)))))

;; END PRELUDE

(define (regex-alt? re)
  (and (pair? re) (eq? (car re) 'alt)))
(define (regex-seq? re)
  (and (pair? re) (eq? (car re) 'seq)))
(define (regex-rep? re)
  (and (pair? re) (eq? (car re) 'rep)))
(define (regex-atom? re)
  (or (char? re) (symbol? re)))
(define (match-seq re f)
  (and (regex-seq? re)
    (f (cadr re) (caddr re))))
(define (match-alt re f)
  (and (regex-alt? re)
    (f (cadr re) (caddr re))))
(define (match-rep re f)
  (and (regex-rep? re)
    (f (cadr re))))
(define (seq pat1 pat2)
  (cond
    ((eq? #f pat1) #f)
    ((eq? #f pat2) #f)
    ((eq? #t pat1) pat2)
    ((eq? #t pat2) pat1)
    (else (cons 'seq (cons pat1 (cons pat2 '()))))))
(define (alt pat1 pat2)
  (cond
    ((eq? #f pat1) pat2)
    ((eq? #f pat2) pat1)
    (else (cons 'alt (cons pat1 (cons pat2 '()))))))
(define (rep pat)
  (cond
    ((eq? #f pat) #t)
    ((eq? #t pat) #t)
    (else (cons 'rep (cons pat '())))))
(define (regex-empty re)
  (cond
    ((eq? #t re) #t)
    ((eq? #f re) #f)
    ((regex-atom? re) #f)
    ((match-seq re (lambda (pat1 pat2)
                     (seq (regex-empty pat1) (regex-empty pat2)))))
    ((match-alt re (lambda (pat1 pat2)
                     (alt (regex-empty pat1) (regex-empty pat2)))))
    ((regex-rep? re) #t)
    (else #f)))
(define (regex-derivative re c)
  (debug-trace)
  (cond
    ((eq? #t re) #f)
    ((eq? #f re)  #f)
    ((eq? c re)        #t)
    ((regex-atom? re)  #f)
    ((match-seq re     (lambda (pat1 pat2)
                         (alt (seq (d/dc pat1 c) pat2)
                           (seq (regex-empty pat1) (d/dc pat2 c))))))
    ((match-alt re     (lambda (pat1 pat2)
                         (alt (d/dc pat1 c) (d/dc pat2 c)))))
    ((match-rep re     (lambda (pat)
                         (seq (d/dc pat c) (rep pat)))))
    (else #f)
  ))
(define d/dc regex-derivative)
(define (regex-match pattern data)
  (if (null? data)
    (eq? #t (regex-empty pattern))
    (regex-match (d/dc pattern (car data)) (cdr data))))
(define (check-expect check expect)
  (equal? check expect))
(check-expect (regex-match '(seq foo (rep bar))
                  '(foo bar))
  #t)

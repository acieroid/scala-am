;; Example adapted from "Introduction to Parallel Programming", chapter 6
(define (build-vector n init f)
  (letrec ((v (make-vector n init))
           (loop (lambda (i)
                   (if (< i n)
                       (begin
                         (vector-set! v i (f i))
                         (loop (+ i 1)))
                       v))))
    (loop 0)))



(define N (+ 6 42))
(define (make-cities N)
  (build-vector N '()
                (lambda (i)
                  (letrec ((loopj (lambda (j acc)
                                    (if (= j N)
                                        acc
                                        (if (= i j)
                                            (loopj (+ j 1) acc)
                                            (loopj (+ j 1) (cons (cons j (random 100)) acc)))))))
                    (loopj 0 '())))))

(define cities
  ;; At index i, each cons cell represents the edge and their weight
  (make-cities N))

(define (city-count tour) (length tour))
(define (cost-of from to)
  (let ((alist (vector-ref cities from)))
    (cdr (assoc to alist))))
(define (feasible tour to)
  (if (and (< (city-count tour) (- N 1)) (= to 0))
      #f
      (let ((last-city (if (null? tour) 0 (last tour))))
        (if (assoc to (vector-ref cities last-city))
            (not (member to tour))
            #f))))
(define (last l)
  (if (null? l)
      (error "last: empty list")
      (if (null? (cdr l))
          (car l)
          (last (cdr l)))))
(define (tour-cost tour)
  (define (helper t last-city cost)
    (if (null? t)
        cost
        (helper (cdr t) (car t) (+ cost (cost-of last-city (car t))))))
  (helper tour 0 0))
(define (add-city tour city)
  (append tour (list city)))

(define (tsp-seq)
  (define (helper stack best-tour best-cost)
    (if (null? stack)
        best-tour
        (let ((curr-tour (car stack)))
          (if (= (city-count curr-tour) N)
              (let ((curr-cost (tour-cost curr-tour)))
                (if (< curr-cost best-cost)
                    (helper (cdr stack) curr-tour curr-cost)
                    (helper (cdr stack) best-tour best-cost)))
              (letrec ((loop (lambda (i stack)
                               (if (< i 0)
                                   stack
                                   (if (feasible curr-tour i)
                                       (let ((curr-tour2 (add-city curr-tour i)))
                                         (loop (- i 1) (cons curr-tour2 stack)))
                                       (loop (- i 1) stack))))))
                (helper (loop (- N 1) (cdr stack)) best-tour best-cost))))))
  (helper '(()) '()  1000))

(define (enqueue elem q)
  (append q (list elem)))
(define (dequeue q)
  (car q))
(define (tsp nthrds)
  (define best-tour (atom '()))
  (define best-cost (atom 1000))
  (define best-lock (t/new-lock))
  (define (set-best-tour tour cost)
    (t/acquire best-lock)
    (if (< cost (read best-cost))
        (begin
          (reset! best-tour tour)
          (reset! best-cost cost))
        #t)
    (t/release best-lock))
  (define (tsp-thrd my-stack)
    (if (null? my-stack)
        'done
        (let ((curr-tour (car my-stack)))
          (if (= (city-count curr-tour) N)
              (let ((curr-cost (tour-cost curr-tour)))
                (if (< curr-cost (read best-cost))
                    (set-best-tour curr-tour curr-cost)
                    #t)
                (tsp-thrd (cdr my-stack)))
              (letrec ((loop (lambda (i my-stack)
                               (if (< i 0)
                                   my-stack
                                   (if (feasible curr-tour i)
                                       (let ((curr-tour2 (add-city curr-tour i)))
                                         (loop (- i 1) (cons curr-tour2 my-stack)))
                                       (loop (- i 1) my-stack))))))
                (tsp-thrd (loop (- N 1) (cdr my-stack))))))))
  (define (tsp-bootstrap queue)
    (if (null? queue)
        #t
        (if (>= (length queue) nthrds)
            (let ((thrds (map (lambda (tour)
                                  (future (tsp-thrd (list tour))))
                                queue)))
              (map (lambda (t) (deref t)) thrds))
            (let ((curr-tour (dequeue queue)))
              (if (= (city-count curr-tour) N)
                  (let ((curr-cost (tour-cost curr-tour)))
                    (if (< curr-cost (read best-cost))
                        (set-best-tour curr-tour curr-cost)
                        #t)
                    (tsp-bootstrap (cdr queue)))
                  (letrec ((loop (lambda (i queue)
                                   (if (< i 0)
                                       queue
                                       (if (feasible curr-tour i)
                                           (let ((curr-tour2 (add-city curr-tour i)))
                                             (loop (- i 1) (enqueue curr-tour2 queue)))
                                           (loop (- i 1) queue))))))
                    (tsp-bootstrap (loop (- N 1) (cdr queue)))))))))
  (tsp-bootstrap '(()))
  (read best-tour))

(define nthrds 42)
(let ((tsp-sequential (future (tsp-seq)))
      (tsp-concurrent (future (tsp nthrds))))
  (equal? (deref tsp-sequential) (deref tsp-concurrent)))
